import math
from Crypto.Util.number import long_to_bytes

n = 22578835672514965704376575704977243571352316149035656242963928196828989105552927778132146452163376921526095265894940614210893201170411464578532436073865602
e = 65537

c = 790841381975773350757021878569321748843852144233427530025485081504529501329013403762519700704621757851557415840747709754896015384128354635155830859417735

def square_n_multiply(x, n): #c, d
    if(n < 0):
        return square_n_multiply(1//x, -n)
    elif(n == 0):
        return 1
    elif(n&1 == 0):
        return square_n_multiply(x**2, n//2)
    else:
        return x * square_n_multiply(x**2, (n-1)//2)

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


p,q = n//2, 2
thetaN = math.lcm(p-1, q-1)
#d = pow(e, -1, thetaN)
d = modinv(e, thetaN)

#m = square_n_multiply(c, d)%n
m = pow(c, d, n)

print(long_to_bytes(m))


